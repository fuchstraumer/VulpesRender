<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VulpesRender: Allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">VulpesRender
   &#160;<span id="projectnumber">v0.8.7</span>
   </div>
   <div id="projectbrief">A library of Vulkan Primitives</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Allocation</div>  </div>
</div><!--header-->
<div class="contents">

<p>The allocator module encompasses everything required for the operation/use of this project's rather complex GPU memory management subsystem.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structvpr_1_1_allocation_1_1block_allocation"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#structvpr_1_1_allocation_1_1block_allocation">vpr::Allocation::blockAllocation</a></td></tr>
<tr class="separator:structvpr_1_1_allocation_1_1block_allocation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structvpr_1_1_allocation_1_1private_allocation"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#structvpr_1_1_allocation_1_1private_allocation">vpr::Allocation::privateAllocation</a></td></tr>
<tr class="separator:structvpr_1_1_allocation_1_1private_allocation"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvpr_1_1_allocation.html">vpr::Allocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvpr_1_1_allocation.html" title="Allocation class represents a singular allocation: can be a private allocation (i.e, only user of attached DeviceMemory) or a block allocation (bound to sub-region of device memory) ">Allocation</a> class represents a singular allocation: can be a private allocation (i.e, only user of attached DeviceMemory) or a block allocation (bound to sub-region of device memory)  <a href="classvpr_1_1_allocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvpr_1_1_allocation_collection.html">vpr::AllocationCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocation collection is just a vector of MemoryBlocks of the same type.  <a href="classvpr_1_1_allocation_collection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvpr_1_1_allocator.html">vpr::Allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary interface and class of this subsystem.  <a href="classvpr_1_1_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvpr_1_1_allocation_requirements.html">vpr::AllocationRequirements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is the primary item submitted to allocator methods for resource creation.  <a href="structvpr_1_1_allocation_requirements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvpr_1_1_memory_block.html">vpr::MemoryBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classvpr_1_1_memory_block.html" title="A MemoryBlock is a large contiguous region of Vulkan memory of a uniform type (device local...">MemoryBlock</a> is a large contiguous region of Vulkan memory of a uniform type (device local, host coherent, host visible, etc) that other objects bind to subregions of.  <a href="classvpr_1_1_memory_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvpr_1_1_suballocation.html">vpr::Suballocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the process of finding a suitable region to bind to, we need to store things like "SuballocationType", which helps keep track of the precise kind of memory we are looking for and lets us know if its optimally/linearly tiled.  <a href="structvpr_1_1_suballocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structvpr_1_1_suballocation_request"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#structvpr_1_1_suballocation_request">vpr::SuballocationRequest</a></td></tr>
<tr class="memdesc:structvpr_1_1_suballocation_request"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an in-progress allocation that we will shortly attempt to assign a slot to.  <a href="group___allocation.html#structvpr_1_1_suballocation_request">More...</a><br /></td></tr>
<tr class="separator:structvpr_1_1_suballocation_request"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga729c04888e8a0b67bdb473c36221615e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">vpr::SuballocationType</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594">vpr::SuballocationType::Free</a> = 0, 
<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e">vpr::SuballocationType::Unknown</a>, 
<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8">vpr::SuballocationType::Buffer</a>, 
<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9">vpr::SuballocationType::ImageUnknown</a>, 
<br />
&#160;&#160;<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f">vpr::SuballocationType::ImageLinear</a>, 
<a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef">vpr::SuballocationType::ImageOptimal</a>
<br />
 }<tr class="memdesc:ga729c04888e8a0b67bdb473c36221615e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suballocations bound to a single memory block can represent different objects, though one will usually find that they end up grouped together.  <a href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga729c04888e8a0b67bdb473c36221615e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba421ef06b1d6b910602d0180c9eff78"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#gaba421ef06b1d6b910602d0180c9eff78">vpr::ValidationCode</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f">vpr::ValidationCode::VALIDATION_PASSED</a> = 0, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687">vpr::ValidationCode::NULL_MEMORY_HANDLE</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c">vpr::ValidationCode::ZERO_MEMORY_SIZE</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768">vpr::ValidationCode::INCORRECT_SUBALLOC_OFFSET</a>, 
<br />
&#160;&#160;<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7">vpr::ValidationCode::NEED_MERGE_SUBALLOCS</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573">vpr::ValidationCode::FREE_SUBALLOC_COUNT_MISMATCH</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5">vpr::ValidationCode::USED_SUBALLOC_IN_FREE_LIST</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5">vpr::ValidationCode::FREE_SUBALLOC_SORT_INCORRECT</a>, 
<br />
&#160;&#160;<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc">vpr::ValidationCode::FINAL_SIZE_MISMATCH</a>, 
<a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451">vpr::ValidationCode::FINAL_FREE_SIZE_MISMATCH</a>
<br />
 }<tr class="memdesc:gaba421ef06b1d6b910602d0180c9eff78"><td class="mdescLeft">&#160;</td><td class="mdescRight">These validation codes are returned by the memory validation routine, giving information on the error encountered.  <a href="group___allocation.html#gaba421ef06b1d6b910602d0180c9eff78">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaba421ef06b1d6b910602d0180c9eff78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8cf57df2fccbbe7a68b713d93db023c1"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#ga8cf57df2fccbbe7a68b713d93db023c1">vpr::CheckBlocksOnSamePage</a> (const VkDeviceSize &amp;item_a_offset, const VkDeviceSize &amp;item_a_size, const VkDeviceSize &amp;item_b_offset, const VkDeviceSize &amp;page_size)</td></tr>
<tr class="memdesc:ga8cf57df2fccbbe7a68b713d93db023c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Taken from the Vulkan specification, section 11.6 Essentially, we need to ensure that linear and non-linear resources are properly placed on separate memory pages so that they avoid any accidental aliasing.  <a href="group___allocation.html#ga8cf57df2fccbbe7a68b713d93db023c1">More...</a><br /></td></tr>
<tr class="separator:ga8cf57df2fccbbe7a68b713d93db023c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga568ec6e09a10a255e22519e4e1a4f2e3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#ga568ec6e09a10a255e22519e4e1a4f2e3">vpr::CheckBufferImageGranularityConflict</a> (<a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">SuballocationType</a> type_a, <a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">SuballocationType</a> type_b)</td></tr>
<tr class="memdesc:ga568ec6e09a10a255e22519e4e1a4f2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to make sure the two objects of type "type_a" and "type_b" wouldn't cause a conflict with the buffer-image granularity values.  <a href="group___allocation.html#ga568ec6e09a10a255e22519e4e1a4f2e3">More...</a><br /></td></tr>
<tr class="separator:ga568ec6e09a10a255e22519e4e1a4f2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0854824912bca3e22929b2407b1273"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___allocation.html#gabf0854824912bca3e22929b2407b1273">vpr::operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="group___allocation.html#gaba421ef06b1d6b910602d0180c9eff78">ValidationCode</a> &amp;code)</td></tr>
<tr class="memdesc:gabf0854824912bca3e22929b2407b1273"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple and common overload to print enum info to any stream (this also works, FYI, with easylogging++).  <a href="group___allocation.html#gabf0854824912bca3e22929b2407b1273">More...</a><br /></td></tr>
<tr class="separator:gabf0854824912bca3e22929b2407b1273"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The allocator module encompasses everything required for the operation/use of this project's rather complex GPU memory management subsystem. </p>
<p>In Vulkan, allocating VkDeviceMemory objects for every single individual resource requiring GPU memory is wasteful, and not practical: there is a limit in each Vulkan implementation to just how many allocations can exist at one time (sometimes as low as 1024). Thus, we will instead allocate large chunks of memory when a previously unallocated memory type is requested: from there, resources (like buffers, images, etc) will bind to subregions of this larger memory object. Binding is much faster than allocation, and it is also much quicker to de-allocate resources since this only involves registering a newly freed location in this subsystem.</p>
<p>The allocator object is spawned as a member of the LogicalDevice class, but it can be accessed by anyone that can access a logical device. Its relatively safe to access, and should be thread-safe. Utility methods exist to simplify the creation and allocation of VkImage and VkBuffer objects as much as possible, as well.</p>
<p>This module also is minimally complete, at best. It is robust enough to not fail in common usage, and currently has functioned wonderfully in most tasks thrown at it. However, the todo list details stuff that still needs to be done (e.g, further splitting pools and creating some kind of defragmentation system).</p>
<p>Lastly, huge credit to GPU-Open as this is primarily just a slightly more object-oriented/"Modern C++" styled implementation of their <em>excellent</em> memory allocator. This would not have been possible without their work: <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator</a></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><p class="startdd">Further dividing allocation among three size pools, and then still dividing among type in those pools </p>
<p class="enddd">Measure costliness of Validate(), possibly use return codes to fix errors when possible. </p>
</dd></dl>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structvpr_1_1_allocation_1_1block_allocation" id="structvpr_1_1_allocation_1_1block_allocation"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structvpr_1_1_allocation_1_1block_allocation">&#9670;&nbsp;</a></span>vpr::Allocation::blockAllocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct vpr::Allocation::blockAllocation</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_allocation_8hpp_source.html#l00043">43</a> of file <a class="el" href="_allocation_8hpp_source.html">Allocation.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for vpr::Allocation::blockAllocation:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="structvpr_1_1_allocation_1_1block_allocation__coll__graph.svg" width="100%" height="578"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a2e910e41ac3c7b7d269dda693e736ce8"></a>VkDeviceSize</td>
<td class="fieldname">
Offset</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a1c310681867acc2825ae0ea55c7c86db"></a><a class="el" href="classvpr_1_1_memory_block.html">MemoryBlock</a> *</td>
<td class="fieldname">
ParentBlock</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structvpr_1_1_allocation_1_1private_allocation" id="structvpr_1_1_allocation_1_1private_allocation"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structvpr_1_1_allocation_1_1private_allocation">&#9670;&nbsp;</a></span>vpr::Allocation::privateAllocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct vpr::Allocation::privateAllocation</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_allocation_8hpp_source.html#l00048">48</a> of file <a class="el" href="_allocation_8hpp_source.html">Allocation.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a6aca57626ceb41add82d17be604e2b42"></a>VkDeviceMemory</td>
<td class="fieldname">
DvcMemory</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a509f136487f269c94452d86ff1ab6c1c"></a>void *</td>
<td class="fieldname">
MappedData</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a43ca354af497c90e1d2b8a546ae6e829"></a>uint32_t</td>
<td class="fieldname">
MemoryTypeIdx</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af6ce9d069ba9f5d7b3f0e12780f07461"></a>bool</td>
<td class="fieldname">
PersistentlyMapped</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structvpr_1_1_suballocation_request" id="structvpr_1_1_suballocation_request"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structvpr_1_1_suballocation_request">&#9670;&nbsp;</a></span>vpr::SuballocationRequest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct vpr::SuballocationRequest</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents an in-progress allocation that we will shortly attempt to assign a slot to. </p>

<p class="definition">Definition at line <a class="el" href="_suballocation_8hpp_source.html#l00035">35</a> of file <a class="el" href="_suballocation_8hpp_source.html">Suballocation.hpp</a>.</p>
</div><div class="dynheader">
Collaboration diagram for vpr::SuballocationRequest:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structvpr_1_1_suballocation_request__coll__graph.svg" width="207" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abec7089fbabe06aa9c849d7c9b165382"></a>iterator</td>
<td class="fieldname">
FreeSuballocation</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aa0b7cc608718008b543cea33aab059c3"></a>VkDeviceSize</td>
<td class="fieldname">
Offset</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga729c04888e8a0b67bdb473c36221615e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga729c04888e8a0b67bdb473c36221615e">&#9670;&nbsp;</a></span>SuballocationType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">vpr::SuballocationType</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suballocations bound to a single memory block can represent different objects, though one will usually find that they end up grouped together. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594"></a>Free&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8"></a>Buffer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9"></a>ImageUnknown&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f"></a>ImageLinear&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef"></a>ImageOptimal&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_alloc_common_8hpp_source.html#l00032">32</a> of file <a class="el" href="_alloc_common_8hpp_source.html">AllocCommon.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                                 : uint8_t {</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594">Free</a> = 0, <span class="comment">// unused entry</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>, <span class="comment">// could be various cpu storage objects, or extension objects</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8">Buffer</a>,</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9">ImageUnknown</a>, <span class="comment">// image memory without defined tiling - possibly related to extensions</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f">ImageLinear</a>,</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <a class="code" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef">ImageOptimal</a>,</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    };</div><div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f">vpr::SuballocationType::ImageLinear</a></div></div>
<div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594">vpr::SuballocationType::Free</a></div></div>
<div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8">vpr::SuballocationType::Buffer</a></div></div>
<div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9">vpr::SuballocationType::ImageUnknown</a></div></div>
<div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e">vpr::SuballocationType::Unknown</a></div></div>
<div class="ttc" id="group___allocation_html_gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef"><div class="ttname"><a href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef">vpr::SuballocationType::ImageOptimal</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="gaba421ef06b1d6b910602d0180c9eff78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba421ef06b1d6b910602d0180c9eff78">&#9670;&nbsp;</a></span>ValidationCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___allocation.html#gaba421ef06b1d6b910602d0180c9eff78">vpr::ValidationCode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These validation codes are returned by the memory validation routine, giving information on the error encountered. </p>
<p>They will also be printed to the console, if it is enabled, and logged to the log file as well. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f"></a>VALIDATION_PASSED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687"></a>NULL_MEMORY_HANDLE&#160;</td><td class="fielddoc"><p><a class="el" href="structvpr_1_1_suballocation.html" title="During the process of finding a suitable region to bind to, we need to store things like &quot;Suballocati...">Suballocation</a>'s memory handle is invalid. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c"></a>ZERO_MEMORY_SIZE&#160;</td><td class="fielddoc"><p><a class="el" href="structvpr_1_1_suballocation.html" title="During the process of finding a suitable region to bind to, we need to store things like &quot;Suballocati...">Suballocation</a>'s memory size is zero. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768"></a>INCORRECT_SUBALLOC_OFFSET&#160;</td><td class="fielddoc"><p>Offset of suballocation is incorrect: it may overlap with another, or it may be placed beyond the range of the allocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7"></a>NEED_MERGE_SUBALLOCS&#160;</td><td class="fielddoc"><p>Two adjacent free suballoctions: merge them into one bigger suballocation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573"></a>FREE_SUBALLOC_COUNT_MISMATCH&#160;</td><td class="fielddoc"><p>We found more free suballocations while validating than there are in the free suballocation list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5"></a>USED_SUBALLOC_IN_FREE_LIST&#160;</td><td class="fielddoc"><p>Non-free suballocation in free suballocation list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5"></a>FREE_SUBALLOC_SORT_INCORRECT&#160;</td><td class="fielddoc"><p>Free suballocation list is sorted by available space descending: sorting is incorrect and smaller free region is before larger free region. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc"></a>FINAL_SIZE_MISMATCH&#160;</td><td class="fielddoc"><p>Calculated offset as sum of all suballoc sizes is not equal to allocations total size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451"></a>FINAL_FREE_SIZE_MISMATCH&#160;</td><td class="fielddoc"><p>Calculated total available size doesn't match stored available size. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_alloc_common_8hpp_source.html#l00045">45</a> of file <a class="el" href="_alloc_common_8hpp_source.html">AllocCommon.hpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;                              : uint8_t {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f">VALIDATION_PASSED</a> = 0,</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687">NULL_MEMORY_HANDLE</a>,</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c">ZERO_MEMORY_SIZE</a>,</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768">INCORRECT_SUBALLOC_OFFSET</a>,</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7">NEED_MERGE_SUBALLOCS</a>,</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573">FREE_SUBALLOC_COUNT_MISMATCH</a>,</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5">USED_SUBALLOC_IN_FREE_LIST</a>,</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5">FREE_SUBALLOC_SORT_INCORRECT</a>,</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc">FINAL_SIZE_MISMATCH</a>,</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <a class="code" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451">FINAL_FREE_SIZE_MISMATCH</a>,</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    };</div><div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f">vpr::ValidationCode::VALIDATION_PASSED</a></div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7">vpr::ValidationCode::NEED_MERGE_SUBALLOCS</a></div><div class="ttdoc">Two adjacent free suballoctions: merge them into one bigger suballocation. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5">vpr::ValidationCode::FREE_SUBALLOC_SORT_INCORRECT</a></div><div class="ttdoc">Free suballocation list is sorted by available space descending: sorting is incorrect and smaller fre...</div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5">vpr::ValidationCode::USED_SUBALLOC_IN_FREE_LIST</a></div><div class="ttdoc">Non-free suballocation in free suballocation list. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c">vpr::ValidationCode::ZERO_MEMORY_SIZE</a></div><div class="ttdoc">Suballocation&amp;#39;s memory size is zero. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768">vpr::ValidationCode::INCORRECT_SUBALLOC_OFFSET</a></div><div class="ttdoc">Offset of suballocation is incorrect: it may overlap with another, or it may be placed beyond the ran...</div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451">vpr::ValidationCode::FINAL_FREE_SIZE_MISMATCH</a></div><div class="ttdoc">Calculated total available size doesn&amp;#39;t match stored available size. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687">vpr::ValidationCode::NULL_MEMORY_HANDLE</a></div><div class="ttdoc">Suballocation&amp;#39;s memory handle is invalid. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc">vpr::ValidationCode::FINAL_SIZE_MISMATCH</a></div><div class="ttdoc">Calculated offset as sum of all suballoc sizes is not equal to allocations total size. </div></div>
<div class="ttc" id="group___allocation_html_ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573"><div class="ttname"><a href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573">vpr::ValidationCode::FREE_SUBALLOC_COUNT_MISMATCH</a></div><div class="ttdoc">We found more free suballocations while validating than there are in the free suballocation list...</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8cf57df2fccbbe7a68b713d93db023c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cf57df2fccbbe7a68b713d93db023c1">&#9670;&nbsp;</a></span>CheckBlocksOnSamePage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool vpr::CheckBlocksOnSamePage </td>
          <td>(</td>
          <td class="paramtype">const VkDeviceSize &amp;&#160;</td>
          <td class="paramname"><em>item_a_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize &amp;&#160;</td>
          <td class="paramname"><em>item_a_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize &amp;&#160;</td>
          <td class="paramname"><em>item_b_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkDeviceSize &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Taken from the Vulkan specification, section 11.6 Essentially, we need to ensure that linear and non-linear resources are properly placed on separate memory pages so that they avoid any accidental aliasing. </p>
<p>Linear resources are just those that could be read like any other memory region, without any particular optimization for size or access speed. Optimally tiled resources are those that are tiled either by the hardware drivers, or the Vulkan implementation. Think of things like Z-Order curve encoding for texture data, or block-based compression for DDS/KTX texture formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_a_offset</td><td>non-linear object's offset </td></tr>
    <tr><td class="paramname">item_a_size</td><td>non-linear object's size </td></tr>
    <tr><td class="paramname">item_b_offset</td><td>linear object's offset </td></tr>
    <tr><td class="paramname">item_b_size</td><td>linear object's size </td></tr>
    <tr><td class="paramname">page_size</td><td>almost universally tends to be the bufferImageGranularity value retrieved by the parent <a class="el" href="classvpr_1_1_allocator.html" title="The primary interface and class of this subsystem. ">Allocator</a> class. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_alloc_common_8hpp_source.html#l00107">107</a> of file <a class="el" href="_alloc_common_8hpp_source.html">AllocCommon.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="_memory_block_8cpp_source.html#l00234">vpr::MemoryBlock::VerifySuballocation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                                                                                                                                                                             {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        assert(item_a_offset + item_a_size &lt;= item_b_offset &amp;&amp; item_a_size &gt; 0 &amp;&amp; page_size &gt; 0);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        VkDeviceSize item_a_end = item_a_offset + item_a_size - 1;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        VkDeviceSize item_a_end_page = item_a_end &amp; ~(page_size - 1);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        VkDeviceSize item_b_start_Page = item_b_offset &amp; ~(page_size - 1);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        <span class="keywordflow">return</span> item_a_end_page == item_b_start_Page;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    }</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group___allocation_ga8cf57df2fccbbe7a68b713d93db023c1_icgraph.svg" width="660" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga568ec6e09a10a255e22519e4e1a4f2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga568ec6e09a10a255e22519e4e1a4f2e3">&#9670;&nbsp;</a></span>CheckBufferImageGranularityConflict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool vpr::CheckBufferImageGranularityConflict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">SuballocationType</a>&#160;</td>
          <td class="paramname"><em>type_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___allocation.html#ga729c04888e8a0b67bdb473c36221615e">SuballocationType</a>&#160;</td>
          <td class="paramname"><em>type_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks to make sure the two objects of type "type_a" and "type_b" wouldn't cause a conflict with the buffer-image granularity values. </p>
<p>Returns true if conflict, false if no conflict. This is unlike the CheckBlocksOnSamePage method, in that it doesn't check memory location and alignment values, merely comparing the resource types for incompatabilities. This is used to avoid the more detailed checks like CheckBlocksOnSamePage (and the corrections required if this also fails)</p>
<p>BufferImageGranularity specifies interactions between linear and non-linear resources, so we check based on those. </p>

<p class="definition">Definition at line <a class="el" href="_alloc_common_8hpp_source.html#l00124">124</a> of file <a class="el" href="_alloc_common_8hpp_source.html">AllocCommon.hpp</a>.</p>

<p class="reference">References <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8">vpr::Buffer</a>, <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594">vpr::Free</a>, <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615eabb63562f6302e971e7c3095b4746816f">vpr::ImageLinear</a>, <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef">vpr::ImageOptimal</a>, <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9">vpr::ImageUnknown</a>, and <a class="el" href="group___allocation.html#gga729c04888e8a0b67bdb473c36221615ea88183b946cc5f0e8c96b2e66e1c74a7e">vpr::Unknown</a>.</p>

<p class="reference">Referenced by <a class="el" href="_memory_block_8cpp_source.html#l00234">vpr::MemoryBlock::VerifySuballocation()</a>.</p>
<div class="fragment"><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                                                                                         {</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;        <span class="keywordflow">if</span> (type_a &gt; type_b) {</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            std::swap(type_a, type_b);</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;        }</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <span class="keywordflow">switch</span> (type_a) {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        <span class="keywordflow">case</span> SuballocationType::Free:</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordflow">case</span> SuballocationType::Unknown:</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            <span class="comment">// best be conservative and play it safe: return true</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">case</span> SuballocationType::Buffer:</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;            <span class="comment">// unknown return is playing it safe again, optimal return is because optimal tiling and linear buffers don&#39;t mix</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;            <span class="keywordflow">return</span> type_b == SuballocationType::ImageUnknown || type_b == SuballocationType::ImageOptimal;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">case</span> SuballocationType::ImageUnknown:</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;            <span class="keywordflow">return</span> type_b == SuballocationType::ImageUnknown || type_b == SuballocationType::ImageOptimal || type_b == SuballocationType::ImageLinear;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        <span class="keywordflow">case</span> SuballocationType::ImageLinear:</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;            <span class="keywordflow">return</span> type_b == SuballocationType::ImageOptimal;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keywordflow">case</span> SuballocationType::ImageOptimal:</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="keywordflow">throw</span> std::domain_error(<span class="stringliteral">&quot;Reached invalid case in SuballocationType-based switch statement!&quot;</span>);</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;        }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    }</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="group___allocation_ga568ec6e09a10a255e22519e4e1a4f2e3_icgraph.svg" width="100%" height="300"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>

</div>
</div>
<a id="gabf0854824912bca3e22929b2407b1273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0854824912bca3e22929b2407b1273">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vpr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___allocation.html#gaba421ef06b1d6b910602d0180c9eff78">ValidationCode</a> &amp;&#160;</td>
          <td class="paramname"><em>code</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a simple and common overload to print enum info to any stream (this also works, FYI, with easylogging++). </p>
<p>A note to make, however, is that compilers running at W4/Wall warning levels will warn that this method is unreferenced in release mode, if validation is not forced. As the memory verification routine is not used in this case, much of that code will fold away but should still be left in for debug builds. </p>

<p class="definition">Definition at line <a class="el" href="_memory_block_8cpp_source.html#l00019">19</a> of file <a class="el" href="_memory_block_8cpp_source.html">MemoryBlock.cpp</a>.</p>

<p class="reference">References <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451">vpr::FINAL_FREE_SIZE_MISMATCH</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc">vpr::FINAL_SIZE_MISMATCH</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573">vpr::FREE_SUBALLOC_COUNT_MISMATCH</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5">vpr::FREE_SUBALLOC_SORT_INCORRECT</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768">vpr::INCORRECT_SUBALLOC_OFFSET</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7">vpr::NEED_MERGE_SUBALLOCS</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687">vpr::NULL_MEMORY_HANDLE</a>, <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5">vpr::USED_SUBALLOC_IN_FREE_LIST</a>, and <a class="el" href="group___allocation.html#ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c">vpr::ZERO_MEMORY_SIZE</a>.</p>

<p class="reference">Referenced by <a class="el" href="easylogging_09_09_8h_source.html#l02917">el::base::MessageBuilder::operator&lt;&lt;()</a>, <a class="el" href="easylogging_09_09_8h_source.html#l01279">el::base::utils::CommandLineArgs::setArgs()</a>, and <a class="el" href="easylogging_09_09_8h_source.html#l03195">el::base::MessageBuilder::writeIterator()</a>.</p>
<div class="fragment"><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;                                                                        {</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <span class="keywordflow">switch</span> (code) {</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        <span class="keywordflow">case</span> ValidationCode::NULL_MEMORY_HANDLE:</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Null memory handle.&quot;</span>;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        <span class="keywordflow">case</span> ValidationCode::ZERO_MEMORY_SIZE:</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Zero memory size.&quot;</span>;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        <span class="keywordflow">case</span> ValidationCode::INCORRECT_SUBALLOC_OFFSET:</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Incorrect suballocation offset.&quot;</span>;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <span class="keywordflow">case</span> ValidationCode::NEED_MERGE_SUBALLOCS:</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Adjacent free suballocations not merged.&quot;</span>;</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        <span class="keywordflow">case</span> ValidationCode::FREE_SUBALLOC_COUNT_MISMATCH:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Mismatch between counted and caculated quantity of free suballocations.&quot;</span>;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordflow">case</span> ValidationCode::USED_SUBALLOC_IN_FREE_LIST:</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Used suballocation in free/available suballocation list.&quot;</span>;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">case</span> ValidationCode::FREE_SUBALLOC_SORT_INCORRECT:</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Sorting of available suballocations not correct.&quot;</span>;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        <span class="keywordflow">case</span> ValidationCode::FINAL_SIZE_MISMATCH:</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Declared total size of allocation doesn&#39;t match calculated total size.&quot;</span>;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordflow">case</span> ValidationCode::FINAL_FREE_SIZE_MISMATCH:</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            os &lt;&lt; <span class="stringliteral">&quot;Declared total free size doesn&#39;t match caculated total free size.&quot;</span>;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            <span class="keywordflow">break</span>;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        }</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        <span class="keywordflow">return</span> os;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="group___allocation_gabf0854824912bca3e22929b2407b1273_icgraph.svg" width="338" height="183"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
