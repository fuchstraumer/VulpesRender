<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="group___allocation" kind="group">
    <compoundname>Allocation</compoundname>
    <title>Allocation</title>
    <innerclass refid="classvpr_1_1_allocation" prot="public">vpr::Allocation</innerclass>
    <innerclass refid="structvpr_1_1_allocation_requirements" prot="public">vpr::AllocationRequirements</innerclass>
    <innerclass refid="classvpr_1_1_allocator" prot="public">vpr::Allocator</innerclass>
    <innerclass refid="classvpr_1_1_allocation_collection" prot="public">vpr::AllocationCollection</innerclass>
    <innerclass refid="classvpr_1_1_memory_block" prot="public">vpr::MemoryBlock</innerclass>
    <innerclass refid="structvpr_1_1_suballocation" prot="public">vpr::Suballocation</innerclass>
    <innerclass refid="structvpr_1_1_suballocation_request" prot="public">vpr::SuballocationRequest</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group___allocation_1gaba421ef06b1d6b910602d0180c9eff78" prot="public" static="no" strong="yes">
        <type>uint8_t</type>
        <name>ValidationCode</name>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a76c3ec4c3969badcdd02e0c88b07077f" prot="public">
          <name>VALIDATION_PASSED</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687" prot="public">
          <name>NULL_MEMORY_HANDLE</name>
          <briefdescription>
<para><ref refid="structvpr_1_1_suballocation" kindref="compound">Suballocation</ref>&apos;s memory handle is invalid. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c" prot="public">
          <name>ZERO_MEMORY_SIZE</name>
          <briefdescription>
<para><ref refid="structvpr_1_1_suballocation" kindref="compound">Suballocation</ref>&apos;s memory size is zero. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768" prot="public">
          <name>INCORRECT_SUBALLOC_OFFSET</name>
          <briefdescription>
<para>Offset of suballocation is incorrect: it may overlap with another, or it may be placed beyond the range of the allocation. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7" prot="public">
          <name>NEED_MERGE_SUBALLOCS</name>
          <briefdescription>
<para>Two adjacent free suballoctions: merge them into one bigger suballocation. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573" prot="public">
          <name>FREE_SUBALLOC_COUNT_MISMATCH</name>
          <briefdescription>
<para>We found more free suballocations while validating than there are in the free suballocation list. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5" prot="public">
          <name>USED_SUBALLOC_IN_FREE_LIST</name>
          <briefdescription>
<para>Non-free suballocation in free suballocation list. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5" prot="public">
          <name>FREE_SUBALLOC_SORT_INCORRECT</name>
          <briefdescription>
<para>Free suballocation list is sorted by available space descending: sorting is incorrect and smaller free region is before larger free region. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc" prot="public">
          <name>FINAL_SIZE_MISMATCH</name>
          <briefdescription>
<para>Calculated offset as sum of all suballoc sizes is not equal to allocations total size. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451" prot="public">
          <name>FINAL_FREE_SIZE_MISMATCH</name>
          <briefdescription>
<para>Calculated total available size doesn&apos;t match stored available size. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>These validation codes are returned by the memory validation routine, giving information on the error encountered. </para>        </briefdescription>
        <detaileddescription>
<para>They will also be printed to the console, if it is enabled, and logged to the log file as well. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="alloc/src/AllocCommon.hpp" line="33" column="1" bodyfile="alloc/src/AllocCommon.hpp" bodystart="33" bodyend="53"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group___allocation_1ga8cf57df2fccbbe7a68b713d93db023c1" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr bool</type>
        <definition>static constexpr bool vpr::CheckBlocksOnSamePage</definition>
        <argsstring>(const VkDeviceSize &amp;item_a_offset, const VkDeviceSize &amp;item_a_size, const VkDeviceSize &amp;item_b_offset, const VkDeviceSize &amp;page_size)</argsstring>
        <name>CheckBlocksOnSamePage</name>
        <param>
          <type>const VkDeviceSize &amp;</type>
          <declname>item_a_offset</declname>
        </param>
        <param>
          <type>const VkDeviceSize &amp;</type>
          <declname>item_a_size</declname>
        </param>
        <param>
          <type>const VkDeviceSize &amp;</type>
          <declname>item_b_offset</declname>
        </param>
        <param>
          <type>const VkDeviceSize &amp;</type>
          <declname>page_size</declname>
        </param>
        <briefdescription>
<para>Taken from the Vulkan specification, section 11.6 Essentially, we need to ensure that linear and non-linear resources are properly placed on separate memory pages so that they avoid any accidental aliasing. </para>        </briefdescription>
        <detaileddescription>
<para>Linear resources are just those that could be read like any other memory region, without any particular optimization for size or access speed. Optimally tiled resources are those that are tiled either by the hardware drivers, or the Vulkan implementation. Think of things like Z-Order curve encoding for texture data, or block-based compression for DDS/KTX texture formats. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>item_a_offset</parametername>
</parameternamelist>
<parameterdescription>
<para>non-linear object&apos;s offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>item_a_size</parametername>
</parameternamelist>
<parameterdescription>
<para>non-linear object&apos;s size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>item_b_offset</parametername>
</parameternamelist>
<parameterdescription>
<para>linear object&apos;s offset </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>item_b_size</parametername>
</parameternamelist>
<parameterdescription>
<para>linear object&apos;s size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>page_size</parametername>
</parameternamelist>
<parameterdescription>
<para>almost universally tends to be the bufferImageGranularity value retrieved by the parent <ref refid="classvpr_1_1_allocator" kindref="compound">Allocator</ref> class. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="alloc/src/AllocCommon.hpp" line="74" column="1" bodyfile="alloc/src/AllocCommon.hpp" bodystart="74" bodyend="80"/>
        <referencedby refid="classvpr_1_1_memory_block_1a3eb796b49ef07360203e2fe8c099809b" compoundref="_memory_block_8cpp" startline="268" endline="348">vpr::MemoryBlock::VerifySuballocation</referencedby>
      </memberdef>
      <memberdef kind="function" id="group___allocation_1ga568ec6e09a10a255e22519e4e1a4f2e3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr bool</type>
        <definition>static constexpr bool vpr::CheckBufferImageGranularityConflict</definition>
        <argsstring>(SuballocationType type_a, SuballocationType type_b)</argsstring>
        <name>CheckBufferImageGranularityConflict</name>
        <param>
          <type>SuballocationType</type>
          <declname>type_a</declname>
        </param>
        <param>
          <type>SuballocationType</type>
          <declname>type_b</declname>
        </param>
        <briefdescription>
<para>Checks to make sure the two objects of type &quot;type_a&quot; and &quot;type_b&quot; wouldn&apos;t cause a conflict with the buffer-image granularity values. </para>        </briefdescription>
        <detaileddescription>
<para>Returns true if conflict, false if no conflict. This is unlike the CheckBlocksOnSamePage method, in that it doesn&apos;t check memory location and alignment values, merely comparing the resource types for incompatabilities. This is used to avoid the more detailed checks like CheckBlocksOnSamePage (and the corrections required if this also fails)</para><para>BufferImageGranularity specifies interactions between linear and non-linear resources, so we check based on those. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="alloc/src/MemoryBlock.cpp" line="21" column="1" bodyfile="alloc/src/MemoryBlock.cpp" bodystart="21" bodyend="44"/>
        <references refid="namespacevpr_1a729c04888e8a0b67bdb473c36221615ea7e62bc342f41c946868f0ea6f0b712d8">vpr::Buffer</references>
        <references refid="namespacevpr_1a729c04888e8a0b67bdb473c36221615eab24ce0cd392a5b0b8dedc66c25213594">vpr::Free</references>
        <references refid="namespacevpr_1a494552c6fdda99313008c4a5e61a79fcabb63562f6302e971e7c3095b4746816f">vpr::ImageLinear</references>
        <references refid="namespacevpr_1a729c04888e8a0b67bdb473c36221615ead21ea5ec68ed3adc669014fe4ca2daef">vpr::ImageOptimal</references>
        <references refid="namespacevpr_1a729c04888e8a0b67bdb473c36221615ea7d16f3f47038f8ac0d8615e4b83f55d9">vpr::ImageUnknown</references>
        <references refid="namespacevpr_1a494552c6fdda99313008c4a5e61a79fca88183b946cc5f0e8c96b2e66e1c74a7e">vpr::Unknown</references>
        <referencedby refid="classvpr_1_1_memory_block_1a3eb796b49ef07360203e2fe8c099809b" compoundref="_memory_block_8cpp" startline="268" endline="348">vpr::MemoryBlock::VerifySuballocation</referencedby>
      </memberdef>
      <memberdef kind="function" id="group___allocation_1gabf0854824912bca3e22929b2407b1273" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; vpr::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const ValidationCode &amp;code)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const ValidationCode &amp;</type>
          <declname>code</declname>
        </param>
        <briefdescription>
<para>This is a simple and common overload to print enum info to any stream (this also works, FYI, with easylogging++). </para>        </briefdescription>
        <detaileddescription>
<para>A note to make, however, is that compilers running at W4/Wall warning levels will warn that this method is unreferenced in release mode, if validation is not forced. As the memory verification routine is not used in this case, much of that code will fold away but should still be left in for debug builds. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="alloc/src/MemoryBlock.cpp" line="53" column="1" bodyfile="alloc/src/MemoryBlock.cpp" bodystart="53" bodyend="86"/>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a9d79688e901f5c4aa31129a2fe7f3451">vpr::FINAL_FREE_SIZE_MISMATCH</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a88ad6448cd6f1d495139e026eb3424dc">vpr::FINAL_SIZE_MISMATCH</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78ac38471be1ba1406851e804110887b573">vpr::FREE_SUBALLOC_COUNT_MISMATCH</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a4510c59ac7d838e715255649c3fd77a5">vpr::FREE_SUBALLOC_SORT_INCORRECT</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a76d83e278aa0df0c5edd0e99d70ee768">vpr::INCORRECT_SUBALLOC_OFFSET</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a81f141477ffccd0d5a9c6a2353348cc7">vpr::NEED_MERGE_SUBALLOCS</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a641efe802ee0e2d0cbc7a0c46e91e687">vpr::NULL_MEMORY_HANDLE</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a99db430a4a1b654dc0c46b77a028d4a5">vpr::USED_SUBALLOC_IN_FREE_LIST</references>
        <references refid="group___allocation_1ggaba421ef06b1d6b910602d0180c9eff78a2ceb3550d64b57a93e2896bcf767112c">vpr::ZERO_MEMORY_SIZE</references>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>The allocator module encompasses everything required for the operation/use of this project&apos;s rather complex GPU memory management subsystem. </para>    </briefdescription>
    <detaileddescription>
<para>In Vulkan, allocating VkDeviceMemory objects for every single individual resource requiring GPU memory is wasteful, and not practical: there is a limit in each Vulkan implementation to just how many allocations can exist at one time (sometimes as low as 1024). Thus, we will instead allocate large chunks of memory when a previously unallocated memory type is requested: from there, resources (like buffers, images, etc) will bind to subregions of this larger memory object. Binding is much faster than allocation, and it is also much quicker to de-allocate resources since this only involves registering a newly freed location in this subsystem.</para><para>The allocator object is spawned as a member of the LogicalDevice class, but it can be accessed by anyone that can access a logical device. Its relatively safe to access, and should be thread-safe. Utility methods exist to simplify the creation and allocation of VkImage and VkBuffer objects as much as possible, as well.</para><para>This module also is minimally complete, at best. It is robust enough to not fail in common usage, and currently has functioned wonderfully in most tasks thrown at it. However, the todo list details stuff that still needs to be done (e.g, further splitting pools and creating some kind of defragmentation system).</para><para>Lastly, huge credit to GPU-Open as this is primarily just a slightly more object-oriented/&quot;Modern C++&quot; styled implementation of their <emphasis>excellent</emphasis> memory allocator. This would not have been possible without their work: <ulink url="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator</ulink> </para>    </detaileddescription>
  </compounddef>
</doxygen>
